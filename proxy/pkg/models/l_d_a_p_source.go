// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LDAPSource l d a p source
//
// swagger:model LDAPSource
type LDAPSource struct {

	// Addition Group DN
	//
	// Prepended to Base DN for Group-queries.
	AdditionalGroupDn string `json:"additional_group_dn,omitempty"`

	// Addition User DN
	//
	// Prepended to Base DN for User-queries.
	AdditionalUserDn string `json:"additional_user_dn,omitempty"`

	// Authentication flow
	//
	// Flow to use when authenticating existing users.
	// Format: uuid
	AuthenticationFlow *strfmt.UUID `json:"authentication_flow,omitempty"`

	// Base DN
	// Required: true
	// Min Length: 1
	BaseDn *string `json:"base_dn"`

	// Bind CN
	// Required: true
	// Min Length: 1
	BindCn *string `json:"bind_cn"`

	// Bind password
	// Required: true
	// Min Length: 1
	BindPassword *string `json:"bind_password"`

	// Enabled
	Enabled bool `json:"enabled,omitempty"`

	// Enrollment flow
	//
	// Flow to use when enrolling new users.
	// Format: uuid
	EnrollmentFlow *strfmt.UUID `json:"enrollment_flow,omitempty"`

	// Group object filter
	//
	// Consider Objects matching this filter to be Groups.
	// Min Length: 1
	GroupObjectFilter string `json:"group_object_filter,omitempty"`

	// Name
	//
	// Source's display Name.
	// Required: true
	// Min Length: 1
	Name *string `json:"name"`

	// Object uniqueness field
	//
	// Field which contains a unique Identifier.
	// Min Length: 1
	ObjectUniquenessField string `json:"object_uniqueness_field,omitempty"`

	// Pbm uuid
	// Read Only: true
	// Format: uuid
	Pk strfmt.UUID `json:"pk,omitempty"`

	// property mappings
	// Unique: true
	PropertyMappings []strfmt.UUID `json:"property_mappings"`

	// Server URI
	// Required: true
	// Min Length: 1
	ServerURI *string `json:"server_uri"`

	// Slug
	//
	// Internal source name, used in URLs.
	// Required: true
	// Max Length: 50
	// Min Length: 1
	// Pattern: ^[-a-zA-Z0-9_]+$
	Slug *string `json:"slug"`

	// Enable Start TLS
	StartTLS bool `json:"start_tls,omitempty"`

	// Sync groups
	SyncGroups bool `json:"sync_groups,omitempty"`

	// Sync parent group
	// Format: uuid
	SyncParentGroup *strfmt.UUID `json:"sync_parent_group,omitempty"`

	// Sync users
	SyncUsers bool `json:"sync_users,omitempty"`

	// User group membership field
	//
	// Field which contains Groups of user.
	// Min Length: 1
	UserGroupMembershipField string `json:"user_group_membership_field,omitempty"`

	// User object filter
	//
	// Consider Objects matching this filter to be Users.
	// Min Length: 1
	UserObjectFilter string `json:"user_object_filter,omitempty"`
}

// Validate validates this l d a p source
func (m *LDAPSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthenticationFlow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseDn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBindCn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBindPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnrollmentFlow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupObjectFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectUniquenessField(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePropertyMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSlug(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyncParentGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserGroupMembershipField(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserObjectFilter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LDAPSource) validateAuthenticationFlow(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthenticationFlow) { // not required
		return nil
	}

	if err := validate.FormatOf("authentication_flow", "body", "uuid", m.AuthenticationFlow.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateBaseDn(formats strfmt.Registry) error {

	if err := validate.Required("base_dn", "body", m.BaseDn); err != nil {
		return err
	}

	if err := validate.MinLength("base_dn", "body", string(*m.BaseDn), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateBindCn(formats strfmt.Registry) error {

	if err := validate.Required("bind_cn", "body", m.BindCn); err != nil {
		return err
	}

	if err := validate.MinLength("bind_cn", "body", string(*m.BindCn), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateBindPassword(formats strfmt.Registry) error {

	if err := validate.Required("bind_password", "body", m.BindPassword); err != nil {
		return err
	}

	if err := validate.MinLength("bind_password", "body", string(*m.BindPassword), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateEnrollmentFlow(formats strfmt.Registry) error {

	if swag.IsZero(m.EnrollmentFlow) { // not required
		return nil
	}

	if err := validate.FormatOf("enrollment_flow", "body", "uuid", m.EnrollmentFlow.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateGroupObjectFilter(formats strfmt.Registry) error {

	if swag.IsZero(m.GroupObjectFilter) { // not required
		return nil
	}

	if err := validate.MinLength("group_object_filter", "body", string(m.GroupObjectFilter), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(*m.Name), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateObjectUniquenessField(formats strfmt.Registry) error {

	if swag.IsZero(m.ObjectUniquenessField) { // not required
		return nil
	}

	if err := validate.MinLength("object_uniqueness_field", "body", string(m.ObjectUniquenessField), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validatePk(formats strfmt.Registry) error {

	if swag.IsZero(m.Pk) { // not required
		return nil
	}

	if err := validate.FormatOf("pk", "body", "uuid", m.Pk.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validatePropertyMappings(formats strfmt.Registry) error {

	if swag.IsZero(m.PropertyMappings) { // not required
		return nil
	}

	if err := validate.UniqueItems("property_mappings", "body", m.PropertyMappings); err != nil {
		return err
	}

	for i := 0; i < len(m.PropertyMappings); i++ {

		if err := validate.FormatOf("property_mappings"+"."+strconv.Itoa(i), "body", "uuid", m.PropertyMappings[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *LDAPSource) validateServerURI(formats strfmt.Registry) error {

	if err := validate.Required("server_uri", "body", m.ServerURI); err != nil {
		return err
	}

	if err := validate.MinLength("server_uri", "body", string(*m.ServerURI), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateSlug(formats strfmt.Registry) error {

	if err := validate.Required("slug", "body", m.Slug); err != nil {
		return err
	}

	if err := validate.MinLength("slug", "body", string(*m.Slug), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("slug", "body", string(*m.Slug), 50); err != nil {
		return err
	}

	if err := validate.Pattern("slug", "body", string(*m.Slug), `^[-a-zA-Z0-9_]+$`); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateSyncParentGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.SyncParentGroup) { // not required
		return nil
	}

	if err := validate.FormatOf("sync_parent_group", "body", "uuid", m.SyncParentGroup.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateUserGroupMembershipField(formats strfmt.Registry) error {

	if swag.IsZero(m.UserGroupMembershipField) { // not required
		return nil
	}

	if err := validate.MinLength("user_group_membership_field", "body", string(m.UserGroupMembershipField), 1); err != nil {
		return err
	}

	return nil
}

func (m *LDAPSource) validateUserObjectFilter(formats strfmt.Registry) error {

	if swag.IsZero(m.UserObjectFilter) { // not required
		return nil
	}

	if err := validate.MinLength("user_object_filter", "body", string(m.UserObjectFilter), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LDAPSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LDAPSource) UnmarshalBinary(b []byte) error {
	var res LDAPSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
